#### 多线程和多进程

- 创建进程的三种方式
  - 启动进程的三种方式system, fork, exec 其中system不是理想手段,  进程的创建尽量使用execl,进程内非继承文件描述符需要设置FD_CLOEXEC属性
- linux系统常见调试工具
  - 编译阶段
    - addr2line
  - 运行阶段
    - gdb
    - top 
    - strace 跟踪系统调用
    - coredump
    - valgrind/mstrace 检查内存错误
    - sysRq查询系统信息，包括内存、线程栈、寄存器信息
    - proc文件系统

- 系统问题分析步骤

  - 程序异常

    - 异常中止（如重启）
      - kernel panic 内核分析
      - Signal触发， 生成coredump文件，GDB调试分析
      - OOM valgrind/mstrace分析（可能内存泄露，有可能是栈内存泄露，比如创建了大量线程没有在线程执行结束后回收（没有detach或pthread_join））

    - 异常不中止（如卡死）
      - CPU占用率高：线程空转，top分析cpu占用，gdb跟踪程序执行，bt然后发现一直停留在某个函数
      - CPU占用率不高：死锁，gdb或者sysRq分析下堆栈

- 什么情况会导致coredump

  - 线程栈溢出，栈设置的值小于实际使用的值
  - 操作空指针
  - 除以0

- 问题实例

  - 消息队列需要调用mqUnlink才能真正回收不使用的消息队列，mqClose只是关闭，不是销毁
  - ps也可以查看线程,  在ps命令中，-T选项可以开启线程查看。下面的命令列出了由进程号为`<pid>`的进程创建的所有线程。`$ ps -T -p <pid>` ;   公司代码可以通过pthreadinfo直接找到线程的pid
  - 内存不足导致重启

- 其它

  - 手动触发coredump, kill -11 pid
  - 多线程常见设计模式： master-worker模式，举例：mater负责处理连接或数据可读，连接或可读后，则worker来处理数据
  - LR与PC： LR是执行完以后返回的，PC是当前取指的代码行，如果指针在动态库，则无法定位源文件及行数
  -  [Linux](http://lib.csdn.net/base/linux)下面有个特性叫OOM killer（Out Of Memory killer），这个东西会在系统内存耗尽的情况下跳出来，选择性的干掉一些进程以求释放一些内存。具体的记录日志是在/var/log/messages中，如果出现了Out of memory字样，说明系统曾经出现过OOM 
  - 为什么泄露会导致OOM ， 因为泄露久了，内存不够用了，当某个进程申请内存时，不够了，就要杀死某个进程了。定位内存碎片的一种思路是，oom了但剩余内存还没有到触发oom的时候

  

#### 内存知识及问题诊断

- os内存分为内核、内核文件系统、应用进程

##### 如何定位内存泄漏

- 确定存在

  - 首先要确定存在内存泄漏，包括top命令、free、cat /proc/meminfo （commited_as），查看是否增大（某些情况下增大是正常的，比如系统启动后加载各种模块）

- 进程

  - status、statm、maps、smaps查看进程信息，包含heap和mmap匿名内存映射

- 线程

  - 查看min_flt增多的线程，缺页中断会越来越多,当使用malloc/mmap等希望访问物理空间的库函数/系统调用后，由于linux并未真正给新创建的vma映射物理页，此时若先进行写操作，将和2产生缺页中断的情况一样；若先进行读操作虽然也会产生缺页异常，将被映射给默认的零页，等再进行写操作时，仍会产生缺页中断，这次必须分配1物理页了，进入写时复制的流程；

  - PS：产生缺页中断的几种情况

    1、当内存管理单元（MMU）中确实没有创建虚拟物理页映射关系，并且在该虚拟地址之后再没有当前进程的线性区（vma）的时候，可以肯定这是一个编码错误，这将杀掉该进程；

    2、当MMU中确实没有创建虚拟页物理页映射关系，并且在该虚拟地址之后存在当前进程的线性区vma的时候，这很可能是缺页中断，并且可能是栈溢出导致的缺页中断；

    3、当使用malloc/mmap等希望访问物理空间的库函数/系统调用后，由于linux并未真正给新创建的vma映射物理页，此时若先进行写操作，将和2产生缺页中断的情况一样；若先进行读操作虽然也会产生缺页异常，将被映射给默认的零页，等再进行写操作时，仍会产生缺页中断，这次必须分配1物理页了，进入写时复制的流程；

    4、当使用fork等系统调用创建子进程时，子进程不论有无自己的vma，它的vma都有对于物理页的映射，但它们共同映射的这些物理页属性为只读，即linux并未给子进程真正分配物理页，当父子进程任何一方要写相应物理页时，导致缺页中断的写时复制；
    ————————————————
    版权声明：本文为CSDN博主「m0_37962600」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
    原文链接：https://blog.csdn.net/m0_37962600/java/article/details/81448553

- 代码段定位

  - 代码走读和静态工具检测、搜索脚本grep所有内存分配语句行，（未配对、根据经验的智能指针）
  - 钩子函数，即替换系统的内存分配函数，然后通过新的内存分配函数增加打印来定位

##### 内存泄露工具

- valgrind
- memwatch
- tcmalloc

#### 待做

- 验证oom,自行写一个进程，实现内存泄漏
